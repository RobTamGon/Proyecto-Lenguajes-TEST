package com.atraparalagato.impl.service;

import com.atraparalagato.base.service.GameService;
import com.atraparalagato.base.model.GameState;
import com.atraparalagato.base.model.GameBoard;
import com.atraparalagato.base.strategy.CatMovementStrategy;
import com.atraparalagato.impl.model.HexPosition;
import com.atraparalagato.impl.model.HexGameState;
import com.atraparalagato.impl.model.HexGameBoard;
import com.atraparalagato.impl.repository.H2GameRepository;
import com.atraparalagato.impl.strategy.AStarCatMovement;

import java.util.*;

/**
 * Implementación de GameService para el juego hexagonal.
 */
public class HexGameService extends GameService<HexPosition> {

    public HexGameService() {
        super(
            new HexGameBoard(5),
            new AStarCatMovement(new HexGameBoard(5)),
            new H2GameRepository(),
            () -> UUID.randomUUID().toString(),
            (size) -> new HexGameBoard(size),
            (gameId) -> new HexGameState(gameId, 5)
        );
    }

    @Override
    protected void initializeGame(GameState<HexPosition> gameState, GameBoard<HexPosition> board) {
        // Por ahora no hace falta inicializar nada más
    }

    public HexGameState createGame(int boardSize, String difficulty, Map<String, Object> options) {
        String gameId = generateGameId();
        HexGameBoard board = new HexGameBoard(boardSize);
        HexGameState gameState = new HexGameState(gameId, boardSize);
        gameState.setGameDifficulty(difficulty);

        configureGameCallbacks(gameState);
        persistGameState(gameState);

        return gameState;
    }

    @Override
    protected HexPosition getTargetPosition(GameState<HexPosition> gameState) {
        // Target position por defecto: borde (por ejemplo, parte derecha)
        return new HexPosition(gameState.getBoardSize(), 0);
    }

    @Override
    public Object getGameStatistics(String gameId) {
        Optional<GameState<HexPosition>> optGame = loadGameState(gameId);

        if (optGame.isEmpty()) {
            return Map.of("error", "Game not found");
        }

        HexGameState gameState = (HexGameState) optGame.get();

        return Map.of(
            "gameId", gameState.getGameId(),
            "status", gameState.getStatus(),
            "moveCount", gameState.getMoveCount(),
            "catPosition", gameState.getCatPosition(),
            "blockedPositions", gameState.getGameBoard().getBlockedPositions().size()
        );
    }

    @Override
    public boolean isValidMove(String gameId, HexPosition position) {
        Optional<GameState<HexPosition>> optGame = loadGameState(gameId);
        return optGame.map(game -> ((HexGameState) game).canExecuteMove(position)).orElse(false);
    }

    @Override
    public Optional<HexPosition> getSuggestedMove(String gameId) {
        Optional<GameState<HexPosition>> optGame = loadGameState(gameId);

        if (optGame.isPresent()) {
            HexGameState gameState = (HexGameState) optGame.get();
            List<HexPosition> possibleMoves = gameState.getGameBoard()
                .getPositionsWhere(pos -> gameState.canExecuteMove(pos));

            if (!possibleMoves.isEmpty()) {
                return Optional.of(possibleMoves.get(0));
            }
        }

        return Optional.empty();
    }
}
